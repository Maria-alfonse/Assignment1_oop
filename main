//File name: CS213-2023â€“S5&S7-20220103-20221172-20220265-A1-FULL.cpp

//Names : Habiba ayman hamed, Mai hassan awad, Maria Alfons Kamel
//IDs : 20220103 , 20221172 , 20220265
//Emails : Habibaayman100205@gmail.com , maih5413@gmail.com , mariaalfonse206@gmail.com

#include <iostream>
#include <fstream>
#include <cstring>
#include <cmath>
#include "bmplib.cpp"

using namespace std;
unsigned char image[SIZE][SIZE];

bool loadImage ();
void saveImage ();
bool doSomethingForImage ();
void BW();
void Flip();
bool Merge();
void Rotate_Image();
void Invert();
void Darken_Lighten();
void Shrink();
void Detect_Edges();
void Blur();
void Crop();
void Mirroring();
void Enlarge_Image();
void Shuffle_Image();
void Skew_Horizontally();
void Skew_Up();

int main()
{
    // to check if the photo's name right else returns to the while loop in the int main
    while(loadImage()){
        loadImage();
    }
    bool state = 1;
    while(state){
        if(doSomethingForImage()) {
            state = 0;
        }
    }
    return 0;
}

// returns 0 if the image's name is correct else returns 1
bool loadImage () {
    char imageFileName[100];
//determine whether we will edit a colored image or a gray scale
    cout<<"Welcome dear user :)\n";
    cout <<"Enter the source image file name: ";
    cin >> imageFileName;

// to form the whole path
    strcat (imageFileName, ".bmp");

// this returns 1 if the name is wrong else returns 0
    return readGSBMP(imageFileName, image);
}

//_________________________________________
void saveImage () {
    char imageFileName[100];

// Get gray scale image target file name
    cout << "Enter the target image file name: ";
    cin >> imageFileName;
// Add to it .bmp extension and load image
    strcat(imageFileName, ".bmp");
    writeGSBMP(imageFileName, image);
}

// returns 1 if any error happens in the filters
bool doSomethingForImage() {
    //print the list to the user
    cout<<"Please enter the index of the selected filter to apply or 0 to exit: ""1-\tBlack & White Filter\n"
          "2-\tInvert Filter\n"
          "3-\tMerge Filter \n"
          "4-\tFlip Image\n"
          "5-\tRotate Image\n"
          "6-\tDarken and Lighten Image\n"
          "7-\tDetect Image Edges \n"
          "8-\tEnlarge Image\n"
          "9-\tShrink Image\n"
          "a-\tMirror 1/2 Image\n"
          "b-\tShuffle Image\n"
          "c-\tBlur Image\n"
          "d-\tCrop Image\n"
          "e-\tSkew Image Right  \n"
          "f-\tSkew Image Up  \n"
          "s-\tSave the image to a file\n"
          "0-\tExit \n";
    //get the user choice and redirects it to do the filter required
    char choose; cin>>choose;
    if(choose == '1'){
        BW();
    }else if(choose == '2') {
        Invert();
    }else if(choose == '3'){
        //returns 1 if the second image's name is wrong
        if(Merge()) return false ;
    }else if(choose == '4'){
        Flip();
    }else if(choose == '5') {
        Rotate_Image();
    }else if(choose == '6'){
        Darken_Lighten();
    }
    else if(choose == '7'){
        Detect_Edges();
    }
    else if(choose == '8'){
        Enlarge_Image();
    }
    else if(choose == '9'){
        Shrink();
    }
    else if(choose == 'a'){
        Mirroring();
    }
    else if(choose == 'b'){
        Shuffle_Image();
    }
    else if(choose == 'c'){
        Blur();
        Blur();
    }
    else if(choose == 'd'){
        Crop();
    }
    else if(choose == 'e'){
        Skew_Horizontally();
    }
    else if(choose == 'f'){
        Skew_Up();
    }
    else if(choose == 's'){
        saveImage();
    }
    else if(choose == '0'){
        return 1;
    }
    return 0;
}

void BW() {
    for(int t=0 ; t<10 ;t++) {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
// if the pixel greater than 127 that's mean it has light colour so turn it to white
                if (image[i][j] > 127)
                    image[i][j] = 255;
                else
//else it has a dark color so turn it to black
                    image[i][j] = 0;
            }
        }
    }
}

void Invert(){
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j) {
//inverting each pixel by subtracting its value from 255
            image[i][j] = 255 - image[i][j];
        }
    }
}

//this function returns 0 if there is no error else it returns 1 to terminates the program
bool Merge(){
// gets the second image's name
    cout<<"Please enter name of image file to merge with: ";
    char imageFileName[100];
    cin >> imageFileName;

//reads the second image
    unsigned char image1[SIZE][SIZE];
    strcat(imageFileName, ".bmp");

// returns 1 if the name is wrong else continues the function
    if(readGSBMP(imageFileName, image1)) return 1;

// this for loop gets the average of the two pixels which are in the same position from the two images
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            image[i][j] = (image[i][j] + image1[i][j]) / 2;
        }
    }
    return 0;
}

void Flip() {
    cout << "flip (h)orizontally or (v)ertically ?: ";
    char c;
    cin >> c;
    if (c == 'h') {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE / 2; j++) {

                int image2 = image[i][j];
                //swapping each pixel with the opposite one in the same row
                image[i][j] = image[i][256 - j];
                image[i][256-j] = image2;
            }
        }
    }
    else{
        for (int i = 0; i < SIZE/2; i++) {
            for (int j = 0; j < SIZE; j++) {
                int image2 = image[i][j];
//swapping each pixel with the opposite one in the same column
                image[i][j] = image[256-i][j];
                image[256-i][j] = image2;
            }
        }
    }
}

void Rotate_Image(){
    int degree;
    cout<<"rotate 90 , 180 or 270 degrees:";
    cin>>degree;

    unsigned char image2[SIZE][SIZE];
    unsigned char image3[SIZE][SIZE];
    unsigned char image4[SIZE][SIZE];
    if (degree == 90) {
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//For each pixel at position (i, j) in the original photo will be (j,n - 1 - i)
//the rows are flipped when transferring to the columns of the new photo
                image2[i][j] = image[j][SIZE - 1 - i];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//doing the same for the other 90
                image3[i][j] = image2[j][SIZE - 1 - i];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//doing the same for the other 90 so its rotated 270
                image4[i][j] = image3[j][SIZE - 1 - i];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//copying 270 rotated image to the original one
                image[i][j] = image4[i][j];
            }
        }
    } else if (degree == 180) {
        for (int i = SIZE - 1; i >= 0; --i) {
            for (int j = SIZE - 1; j >= 0; --j) {
//making the rotated image start from last pixel of the original one
                image2[255 - i][255 - j] = image[i][j];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//copying the new image to the original one
                image[i][j] = image2[i][j];
            }
        }
    } else {
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//For each pixel at position (i, j) in the original photo will be (j,n - 1 - i)
//the rows are flipped when transferring to the columns of the new photo
                image2[i][j] = image[j][SIZE - 1 - i];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
//copying the new photo to the original one
                image[i][j] = image2[i][j];
            }
        }
    }
}

void Darken_Lighten(){

//to know which function to apply(darken or lighten)
    cout<<"Do you want to (d)arken or (l)ighten? : ";
    char b; cin>>b;

//if lighten
    if (b == 'l') {
//like merge function but with a white image (all pixels are white = 255) we get the average of a pixel from the image and a white pixel
        for (int i = 0; i < 256; i++) {
            for (int j = 0; j < 256; j++) {
                image[i][j] = (image[i][j] + 256) / 2;
            }
        }
    } else {
//like merge function but with a black image (all pixels are = 0), we get half the brightness of the pixel
        for (int i = 0; i < 256; i++) {
            for (int j = 0; j < 256; j++) {
                image[i][j] = image[i][j] / 2;
            }
        }
    }
}

void Detect_Edges() {
    ///this function detects edges of the image
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            // if the differance between the color of the selected pixel and the color of the surrounded pixels is greater than 35 -so it's an edge -turn the  selected pixel to black
            if ((abs(image[i + 1][j] - image[i][j]) > 35 && abs(image[i - 1][j] - image[i][j]) > 35) ||
                (abs(image[i][j + 1] - image[i][j]) > 35 && abs(image[i][j - 1] - image[i][j]) > 35)) {
                image[i][j] = 0;
            } else
                image[i][j] = 255;
        }
    }
}

void Enlarge_Image(){
    int part;
    cout<<"wich part do you want to enlarge 1 , 2 , 3 or 4:";
    cin>>part;
    unsigned char image2[SIZE][SIZE];
    if(part == 1){
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting image2 to be white
                image2[i][j] = 255;
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE ; ++j) {
                //representing new image with the first quarter of the old inage
                image2[i][j] = image[i/2][j/2];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //copying new image to the original one
                image[i][j] = image2[i][j];
            }
        }
    }
    else if(part == 2){
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting image2 to be white
                image2[i][j] = 255;
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting new image with second quarter of old image
                image2[i][j] = image[i/2][(j+256)/2];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //copying new image to the original one
                image[i][j] = image2[i][j];
            }
        }
    }
    else if(part == 3){
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting image2 to be white
                image2[i][j] = 255;
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting the new image with third quarter of  old image
                image2[i][j] = image[(i+256)/2][j/2];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //copying new image to the original one
                image[i][j] = image2[i][j];
            }
        }
    }
    else if(part == 4){
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting image2 to be white
                image2[i][j] = 255;
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting the new image with fourth quarter of old image
                image2[i][j] = image[(i + 256) / 2][(j + 256) / 2];
            }
        }
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //copying new image to the original one
                image[i][j] = image2[i][j];
            }
        }
    }
}

void Shrink(){
    ///This function decrease the photo's dimensions to half or third or quarter

    //to ask the user for the ratio to decrease the dimensions
    cout<<"Shrink to (1/2), (1/3) or (1/4)?: ";
    string choice; cin>>choice;

    //in each if condition we will divide the photo to tree regions:
    //           1- the region in which the new image will be diploid
    //           2 & 3 loop is to convert the rest of the image to white

    if (choice == "1/2") {

        //this loops over half the length and width of the photo to save the whole photo in this part (the top left part of the photo)
        for (int i = 0; i < SIZE/2; i++) {
            for (int j = 0; j < SIZE/2; j++) {
                //to save the whole photo in this part we skip a pixel and take the next one we do that for each row and column
                // its like the photo is a chess board, and we only take the black squares in the assigned part
                image[i][j] = (image[i*2][j*2]);
            }
        }

        //this loop will iterate over the lower triangular part of the photo to tern it white
        for(int i=SIZE/2 ; i< SIZE ; i++ ){
            for(int j=0 ; j<SIZE ;j++){
                image[i][j] = 255;
            }
        }
        //this loop will iterate over the top right part of the photo to tern it white
        for(int i=0 ; i< SIZE/2 ; i++ ) {
            for (int j = SIZE / 2; j < SIZE; j++) {
                image[i][j] = 255;
            }
        }

        //the rest two conditions do as the first with difference in the required ratio of the dimensions
    }else if(choice == "1/3"){
        for (int i = 0; i < SIZE/3; i++) {
            for (int j = 0; j < SIZE/3; j++) {
                //this loop skips two pixels and take the third on in each row and column
                image[i][j] = (image[i*3][j*3]);
            }
        }
        for(int i=SIZE/3 ; i< SIZE ; i++ ){
            for(int j=0 ; j<SIZE ;j++){
                image[i][j] = 255;
            }
        }
        for(int i=0 ; i< SIZE/3 ; i++ ){
            for(int j=SIZE/3 ; j<SIZE ;j++){
                image[i][j] = 255;
            }
        }
    }else{
        for (int i = 0; i < SIZE/4; i++) {
            for (int j = 0; j < SIZE/4; j++) {
                //this loop skips three pixels and take the third on in each row and column
                image[i][j] = (image[i*4][j*4]);
            }
        }
        for(int i=SIZE/4 ; i< SIZE ; i++ ){
            for(int j=0 ; j<SIZE ;j++){
                image[i][j] = 255;
            }
        }
        for(int i=0 ; i< SIZE/4 ; i++ ){
            for(int j=SIZE/4 ; j<SIZE ;j++){
                image[i][j] = 255;
            }
        }
    }
}

void Mirroring() {
    ///this function mirrors the right or the left or th lower or the upper half of the image
    string s;
    cout << "(r)ight half or (le)ft half or (u)pper half or (lo)wer half : ";
    cin >> s;
    if (s == "le") {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE / 2; j++) {
                // replacing the right pixel in with the same pixel in the opposite side in the same row
                image[i][SIZE - j] = image[i][j];
            }
        }
    } else if (s == "r") {
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE / 2; j++) {
                // replacing the left pixel in  with the same pixel in the opposite side in the same row
                image[i][j] = image[i][SIZE - j];
            }
        }
    } else if (s == "u") {
        for (int i = 0; i < SIZE / 2; i++) {
            for (int j = 0; j < SIZE; j++) {
                // replacing the lower pixel with the same pixel in the opposite side in the same column
                image[SIZE - i][j] = image[i][j];
            }
        }
    } else {
        for (int i = 0; i < SIZE / 2; i++) {
            for (int j = 0; j < SIZE; j++) {
                // replacing the upper pixel with the same pixel in the lower side in the same column
                image[i][j] = image[SIZE - i][j];
            }
        }

    }
}

void Shuffle_Image() {
    unsigned char image2[SIZE][SIZE];
    unsigned char image3[SIZE][SIZE];
    unsigned char origin[SIZE][SIZE];
    for (int i = 0; i < SIZE; ++i) {
        for (int j = 0; j < SIZE; ++j) {
            origin[i][j] = image[i][j];
            image3[i][j] = image[i][j];
            image2[i][j] = image[i][j];
        }
    }
    cout << "Enter the image new order :";
    int arr[4];
    for (int i = 0; i < 4; ++i) {
        cin >> arr[i];
    }
    if (arr[0] == 1) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //setting the new image's first quarter to be only the first quarter of old image
                image[i][j] = origin[i][j];
            }
        }
    } else if (arr[0] == 2) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //setting the new image's first quarter to be only the second quarter of old image
                image[i][j] = origin[i][j + 127];
            }
        }
    } else if (arr[0] == 3) {
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //setting the new image's first quarter to be only the third quarter of old image
                image[i][j] = origin[i + 127][j];
            }
        }
    } else if (arr[0] == 4) {
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //setting the new image's first quarter to be only the fourth quarter of old image
                image[i][j] = origin[i + 127][j + 127];
            }
        }
    }
    if (arr[1] == 1) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the second quarter of new image
                //setting the new image's second quarter to be only the first quarter of old image
                image[i][j + 127] = origin[i][j];
            }
        }
    } else if (arr[1] == 2) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the second quarter of new image
                //setting the new image's second quarter to be only the second quarter of old image
                image[i][j + 127] = origin[i][j + 127];
            }
        }
    } else if (arr[1] == 3) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the second quarter of new image
                //setting the new image's second quarter to be only the third quarter of old image
                image[i][j + 127] = origin[i + 127][j];
            }
        }
    } else if (arr[1] == 4) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the second quarter of new image
                //setting the new image's second quarter to be only the fourth quarter of old image
                image[i][j + 127] = origin[i + 127][j + 127];
            }
        }
    }
    if (arr[2] == 1) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the third quarter of new image
                //setting the new image's sthird quarter to be only the first quarter of old image
                image[127 + i][j] = origin[i][j];
            }
        }
    } else if (arr[2] == 2) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the third quarter of new image
                //setting the new image's third quarter to be only the second quarter of old image
                image[127 + i][j] = origin[i][127 + j];
            }
        }

    } else if (arr[2] == 3) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the third quarter of new image
                //setting the new image's third quarter to be only the third quarter of old image
                image[127 + i][j] = origin[i + 127][j];
            }
        }
    } else if (arr[2] == 4) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the third quarter of new image
                //setting the new image's third quarter to be only the fourth quarter of old image
                image[127 + i][j] = origin[127 + i][127 + j];
            }
        }
    }
    if (arr[3] == 1) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the fourth quarter of new image
                //setting the new image's fourth quarter to be only the first quarter of old image
                image[i + 127][j + 127] = origin[i][j];
            }
        }
    } else if (arr[3] == 2) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the fourth quarter of new image
                //setting the new image's fourth quarter to be only the second quarter of old image
                image[i + 127][j + 127] = origin[i][j + 127];
            }
        }
    } else if (arr[3] == 3) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the fourth quarter of new image
                //setting the new image's fourth quarter to be only the third quarter of old image
                image[i + 127][j + 127] = origin[i + 127][j];
            }
        }
    } else if (arr[3] == 4) {
        for (int i = 0; i < SIZE / 2; ++i) {
            for (int j = 0; j < SIZE / 2; ++j) {
                //making the fourth quarter of new image
                //setting the new image's fourth quarter to be only the fourth quarter of old image
                image[i + 127][j + 127] = origin[i + 127][j + 127];
            }
        }
    }
}

void Blur(){
        ///this function blurs a photo
        // the for loops loop over a matrix 3x3 and calculate the average of all its colors and reassigns all its pixels with this average
        //for more bluring we repeat this function in the doSomethingForImage() function
        for(int i=1 ; i<SIZE ;i+=2){
            for(int j=1 ; j<SIZE ;j+=2) {
                int average     = (image[i-1][j-1] + image[i-1][j] + image[i-1][j+1]+ image[i][j-1] + image[i][j+1] + image[i+1][j-1] + image[i+1][j] + image[i+1][j+1])/8;
                image[i-1][j-1] = average;
                image[i-1][j]   = average;
                image[i-1][j+1] = average;
                image[i][j-1]   = average;
                image[i][j]     = average;
                image[i][j+1]   = average;
                image[i+1][j-1] = average;
                image[i+1][j]   = average;
                image[i+1][j+1] = average;
            }
        }
    }

void Crop() {
    /// this function cuts selected square from the given image
    int x, z, l, w;
    cout << "enter position, the length and the width of the square :";
    cin >> x >> z >> l >> w;
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            // if the pixel located before the given position or exceeded the given dimensions of the square turn it to white
            if ((i < z || j < x) || (i > z + l || j > x + w)) {
                image[i][j] = 255;
            }
        }
    }
}

void Skew_Horizontally() {
        double rad, step, move;
        move = step / SIZE; //number of steps u need to make
        cout<<"please enter the angle:";
        cin >> rad;
        rad = 90 - rad;
        //changing the angle from degree to radian
        rad = (rad * 22) / (180 * 7);
        double x = 256 / (1 + (1 / tan(rad)));//stores the skew factor that is used to determine the horizontal offset of each pixel
        step = SIZE - x;
        unsigned char image2[SIZE][SIZE];
        for (int i = 0; i < SIZE; ++i) {
            for (int j = 0; j < SIZE; ++j) {
                //shrinking the old image into the new image
                image2[i][(int) (j * x) / SIZE] = image[i][j];
            }
        }
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                //copying the new image into the old one
                image[i][j] = image2[i][j];
                //converting now image2 to be white
                image2[i][j] = 255;
            }
        }
        for (int i = 0; i < SIZE; i++) {
            for (int j = (int) step; j < step + x; j++) {
                //The pixels in the original image are shifted horizontally
                image2[i][j] = image[i][(int) (j - step)];
            }
            step -= move; //decrement the number of steps by 1 after every step
        }
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                //copying skewed image back to the original one
                image[i][j] = image2[i][j];

            }
        }
    }

void Skew_Up(){
    ///to Skew the photo vertically with the required degree
    //to take from the user the required skewness degree
    cout<<"Please enter degree to skew Up: ";
    double degree; cin>>degree;

    //to convert the degree to rad so that the tan function can calculate it
    double degree_rad = (degree*22)/(7*180);

    //to calculate how many pixels to be white in the first column
    double moves = abs(tan(degree_rad)) * 256;

    //the rate to decrease the number of white pixels in columns with each row
    double Rate_to_decrease_moves = moves/256;

    //this is the number of rows that will be skipped to make the skewed photo fit in a 256x256
    double skip = 1 + (moves/255); //its 255 because we use skip in the indexes and there is no index 256

    //in this map we will save the skewed image before compressing it in a 256x256
    unsigned char Skewed_Image[SIZE+int(moves)][SIZE];

    //this loop is to convert the image to white
    for(int i=0 ; i<SIZE+int(moves)  ; i++){
        for(int j=0 ; j<SIZE; j++){
            Skewed_Image[i][j] = 255;
        }
    }

    //these loops iterate over the columns
    for(int j=0 ; j<SIZE ; j++){
        for(int i=0 ; i<SIZE; i++){
            //i+int(move) is to make the photo start from this row and let the previous rows be white
            Skewed_Image[i+int(moves)][j] = image[i][j];
        }
        //then we decrease the moves by the rate to decrease it, to make the photo in the next iteration start from an earlier row
        moves -= Rate_to_decrease_moves ;
    }

    //we iterate over the image to assign it its new skewed image
    for(int i=0 ; i<SIZE ; i++){
        for(int j=0 ; j<SIZE ; j++){
            image[i][j] = Skewed_Image[int(i*skip)][j];
            //the int(i*skip) makes the loop skip the assigned value of rows in this variable which we said before is the 1 + (moves/255)
        }
    }
}
